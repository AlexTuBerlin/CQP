import {
  require_jquery
} from "./chunk-BUDX4IW3.js";
import {
  __toModule
} from "./chunk-A5ICIBVI.js";

// node_modules/bootstrap/js/src/modal.js
var import_jquery2 = __toModule(require_jquery());

// node_modules/bootstrap/js/src/util.js
var import_jquery = __toModule(require_jquery());
var TRANSITION_END = "transitionend";
var MAX_UID = 1e6;
var MILLISECONDS_MULTIPLIER = 1e3;
function toType(obj) {
  if (obj === null || typeof obj === "undefined") {
    return `${obj}`;
  }
  return {}.toString.call(obj).match(/\s([a-z]+)/i)[1].toLowerCase();
}
function getSpecialTransitionEndEvent() {
  return {
    bindType: TRANSITION_END,
    delegateType: TRANSITION_END,
    handle(event) {
      if ((0, import_jquery.default)(event.target).is(this)) {
        return event.handleObj.handler.apply(this, arguments);
      }
      return void 0;
    }
  };
}
function transitionEndEmulator(duration) {
  let called = false;
  (0, import_jquery.default)(this).one(Util.TRANSITION_END, () => {
    called = true;
  });
  setTimeout(() => {
    if (!called) {
      Util.triggerTransitionEnd(this);
    }
  }, duration);
  return this;
}
function setTransitionEndSupport() {
  import_jquery.default.fn.emulateTransitionEnd = transitionEndEmulator;
  import_jquery.default.event.special[Util.TRANSITION_END] = getSpecialTransitionEndEvent();
}
var Util = {
  TRANSITION_END: "bsTransitionEnd",
  getUID(prefix) {
    do {
      prefix += ~~(Math.random() * MAX_UID);
    } while (document.getElementById(prefix));
    return prefix;
  },
  getSelectorFromElement(element) {
    let selector = element.getAttribute("data-target");
    if (!selector || selector === "#") {
      const hrefAttr = element.getAttribute("href");
      selector = hrefAttr && hrefAttr !== "#" ? hrefAttr.trim() : "";
    }
    try {
      return document.querySelector(selector) ? selector : null;
    } catch (_) {
      return null;
    }
  },
  getTransitionDurationFromElement(element) {
    if (!element) {
      return 0;
    }
    let transitionDuration = (0, import_jquery.default)(element).css("transition-duration");
    let transitionDelay = (0, import_jquery.default)(element).css("transition-delay");
    const floatTransitionDuration = parseFloat(transitionDuration);
    const floatTransitionDelay = parseFloat(transitionDelay);
    if (!floatTransitionDuration && !floatTransitionDelay) {
      return 0;
    }
    transitionDuration = transitionDuration.split(",")[0];
    transitionDelay = transitionDelay.split(",")[0];
    return (parseFloat(transitionDuration) + parseFloat(transitionDelay)) * MILLISECONDS_MULTIPLIER;
  },
  reflow(element) {
    return element.offsetHeight;
  },
  triggerTransitionEnd(element) {
    (0, import_jquery.default)(element).trigger(TRANSITION_END);
  },
  supportsTransitionEnd() {
    return Boolean(TRANSITION_END);
  },
  isElement(obj) {
    return (obj[0] || obj).nodeType;
  },
  typeCheckConfig(componentName, config, configTypes) {
    for (const property in configTypes) {
      if (Object.prototype.hasOwnProperty.call(configTypes, property)) {
        const expectedTypes = configTypes[property];
        const value = config[property];
        const valueType = value && Util.isElement(value) ? "element" : toType(value);
        if (!new RegExp(expectedTypes).test(valueType)) {
          throw new Error(`${componentName.toUpperCase()}: Option "${property}" provided type "${valueType}" but expected type "${expectedTypes}".`);
        }
      }
    }
  },
  findShadowRoot(element) {
    if (!document.documentElement.attachShadow) {
      return null;
    }
    if (typeof element.getRootNode === "function") {
      const root = element.getRootNode();
      return root instanceof ShadowRoot ? root : null;
    }
    if (element instanceof ShadowRoot) {
      return element;
    }
    if (!element.parentNode) {
      return null;
    }
    return Util.findShadowRoot(element.parentNode);
  },
  jQueryDetection() {
    if (typeof import_jquery.default === "undefined") {
      throw new TypeError("Bootstrap's JavaScript requires jQuery. jQuery must be included before Bootstrap's JavaScript.");
    }
    const version = import_jquery.default.fn.jquery.split(" ")[0].split(".");
    const minMajor = 1;
    const ltMajor = 2;
    const minMinor = 9;
    const minPatch = 1;
    const maxMajor = 4;
    if (version[0] < ltMajor && version[1] < minMinor || version[0] === minMajor && version[1] === minMinor && version[2] < minPatch || version[0] >= maxMajor) {
      throw new Error("Bootstrap's JavaScript requires at least jQuery v1.9.1 but less than v4.0.0");
    }
  }
};
Util.jQueryDetection();
setTransitionEndSupport();
var util_default = Util;

// node_modules/bootstrap/js/src/modal.js
var NAME = "modal";
var VERSION = "4.6.0";
var DATA_KEY = "bs.modal";
var EVENT_KEY = `.${DATA_KEY}`;
var DATA_API_KEY = ".data-api";
var JQUERY_NO_CONFLICT = import_jquery2.default.fn[NAME];
var ESCAPE_KEYCODE = 27;
var Default = {
  backdrop: true,
  keyboard: true,
  focus: true,
  show: true
};
var DefaultType = {
  backdrop: "(boolean|string)",
  keyboard: "boolean",
  focus: "boolean",
  show: "boolean"
};
var EVENT_HIDE = `hide${EVENT_KEY}`;
var EVENT_HIDE_PREVENTED = `hidePrevented${EVENT_KEY}`;
var EVENT_HIDDEN = `hidden${EVENT_KEY}`;
var EVENT_SHOW = `show${EVENT_KEY}`;
var EVENT_SHOWN = `shown${EVENT_KEY}`;
var EVENT_FOCUSIN = `focusin${EVENT_KEY}`;
var EVENT_RESIZE = `resize${EVENT_KEY}`;
var EVENT_CLICK_DISMISS = `click.dismiss${EVENT_KEY}`;
var EVENT_KEYDOWN_DISMISS = `keydown.dismiss${EVENT_KEY}`;
var EVENT_MOUSEUP_DISMISS = `mouseup.dismiss${EVENT_KEY}`;
var EVENT_MOUSEDOWN_DISMISS = `mousedown.dismiss${EVENT_KEY}`;
var EVENT_CLICK_DATA_API = `click${EVENT_KEY}${DATA_API_KEY}`;
var CLASS_NAME_SCROLLABLE = "modal-dialog-scrollable";
var CLASS_NAME_SCROLLBAR_MEASURER = "modal-scrollbar-measure";
var CLASS_NAME_BACKDROP = "modal-backdrop";
var CLASS_NAME_OPEN = "modal-open";
var CLASS_NAME_FADE = "fade";
var CLASS_NAME_SHOW = "show";
var CLASS_NAME_STATIC = "modal-static";
var SELECTOR_DIALOG = ".modal-dialog";
var SELECTOR_MODAL_BODY = ".modal-body";
var SELECTOR_DATA_TOGGLE = '[data-toggle="modal"]';
var SELECTOR_DATA_DISMISS = '[data-dismiss="modal"]';
var SELECTOR_FIXED_CONTENT = ".fixed-top, .fixed-bottom, .is-fixed, .sticky-top";
var SELECTOR_STICKY_CONTENT = ".sticky-top";
var Modal = class {
  constructor(element, config) {
    this._config = this._getConfig(config);
    this._element = element;
    this._dialog = element.querySelector(SELECTOR_DIALOG);
    this._backdrop = null;
    this._isShown = false;
    this._isBodyOverflowing = false;
    this._ignoreBackdropClick = false;
    this._isTransitioning = false;
    this._scrollbarWidth = 0;
  }
  static get VERSION() {
    return VERSION;
  }
  static get Default() {
    return Default;
  }
  toggle(relatedTarget) {
    return this._isShown ? this.hide() : this.show(relatedTarget);
  }
  show(relatedTarget) {
    if (this._isShown || this._isTransitioning) {
      return;
    }
    if ((0, import_jquery2.default)(this._element).hasClass(CLASS_NAME_FADE)) {
      this._isTransitioning = true;
    }
    const showEvent = import_jquery2.default.Event(EVENT_SHOW, {
      relatedTarget
    });
    (0, import_jquery2.default)(this._element).trigger(showEvent);
    if (this._isShown || showEvent.isDefaultPrevented()) {
      return;
    }
    this._isShown = true;
    this._checkScrollbar();
    this._setScrollbar();
    this._adjustDialog();
    this._setEscapeEvent();
    this._setResizeEvent();
    (0, import_jquery2.default)(this._element).on(EVENT_CLICK_DISMISS, SELECTOR_DATA_DISMISS, (event) => this.hide(event));
    (0, import_jquery2.default)(this._dialog).on(EVENT_MOUSEDOWN_DISMISS, () => {
      (0, import_jquery2.default)(this._element).one(EVENT_MOUSEUP_DISMISS, (event) => {
        if ((0, import_jquery2.default)(event.target).is(this._element)) {
          this._ignoreBackdropClick = true;
        }
      });
    });
    this._showBackdrop(() => this._showElement(relatedTarget));
  }
  hide(event) {
    if (event) {
      event.preventDefault();
    }
    if (!this._isShown || this._isTransitioning) {
      return;
    }
    const hideEvent = import_jquery2.default.Event(EVENT_HIDE);
    (0, import_jquery2.default)(this._element).trigger(hideEvent);
    if (!this._isShown || hideEvent.isDefaultPrevented()) {
      return;
    }
    this._isShown = false;
    const transition = (0, import_jquery2.default)(this._element).hasClass(CLASS_NAME_FADE);
    if (transition) {
      this._isTransitioning = true;
    }
    this._setEscapeEvent();
    this._setResizeEvent();
    (0, import_jquery2.default)(document).off(EVENT_FOCUSIN);
    (0, import_jquery2.default)(this._element).removeClass(CLASS_NAME_SHOW);
    (0, import_jquery2.default)(this._element).off(EVENT_CLICK_DISMISS);
    (0, import_jquery2.default)(this._dialog).off(EVENT_MOUSEDOWN_DISMISS);
    if (transition) {
      const transitionDuration = util_default.getTransitionDurationFromElement(this._element);
      (0, import_jquery2.default)(this._element).one(util_default.TRANSITION_END, (event2) => this._hideModal(event2)).emulateTransitionEnd(transitionDuration);
    } else {
      this._hideModal();
    }
  }
  dispose() {
    [window, this._element, this._dialog].forEach((htmlElement) => (0, import_jquery2.default)(htmlElement).off(EVENT_KEY));
    (0, import_jquery2.default)(document).off(EVENT_FOCUSIN);
    import_jquery2.default.removeData(this._element, DATA_KEY);
    this._config = null;
    this._element = null;
    this._dialog = null;
    this._backdrop = null;
    this._isShown = null;
    this._isBodyOverflowing = null;
    this._ignoreBackdropClick = null;
    this._isTransitioning = null;
    this._scrollbarWidth = null;
  }
  handleUpdate() {
    this._adjustDialog();
  }
  _getConfig(config) {
    config = {
      ...Default,
      ...config
    };
    util_default.typeCheckConfig(NAME, config, DefaultType);
    return config;
  }
  _triggerBackdropTransition() {
    const hideEventPrevented = import_jquery2.default.Event(EVENT_HIDE_PREVENTED);
    (0, import_jquery2.default)(this._element).trigger(hideEventPrevented);
    if (hideEventPrevented.isDefaultPrevented()) {
      return;
    }
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    if (!isModalOverflowing) {
      this._element.style.overflowY = "hidden";
    }
    this._element.classList.add(CLASS_NAME_STATIC);
    const modalTransitionDuration = util_default.getTransitionDurationFromElement(this._dialog);
    (0, import_jquery2.default)(this._element).off(util_default.TRANSITION_END);
    (0, import_jquery2.default)(this._element).one(util_default.TRANSITION_END, () => {
      this._element.classList.remove(CLASS_NAME_STATIC);
      if (!isModalOverflowing) {
        (0, import_jquery2.default)(this._element).one(util_default.TRANSITION_END, () => {
          this._element.style.overflowY = "";
        }).emulateTransitionEnd(this._element, modalTransitionDuration);
      }
    }).emulateTransitionEnd(modalTransitionDuration);
    this._element.focus();
  }
  _showElement(relatedTarget) {
    const transition = (0, import_jquery2.default)(this._element).hasClass(CLASS_NAME_FADE);
    const modalBody = this._dialog ? this._dialog.querySelector(SELECTOR_MODAL_BODY) : null;
    if (!this._element.parentNode || this._element.parentNode.nodeType !== Node.ELEMENT_NODE) {
      document.body.appendChild(this._element);
    }
    this._element.style.display = "block";
    this._element.removeAttribute("aria-hidden");
    this._element.setAttribute("aria-modal", true);
    this._element.setAttribute("role", "dialog");
    if ((0, import_jquery2.default)(this._dialog).hasClass(CLASS_NAME_SCROLLABLE) && modalBody) {
      modalBody.scrollTop = 0;
    } else {
      this._element.scrollTop = 0;
    }
    if (transition) {
      util_default.reflow(this._element);
    }
    (0, import_jquery2.default)(this._element).addClass(CLASS_NAME_SHOW);
    if (this._config.focus) {
      this._enforceFocus();
    }
    const shownEvent = import_jquery2.default.Event(EVENT_SHOWN, {
      relatedTarget
    });
    const transitionComplete = () => {
      if (this._config.focus) {
        this._element.focus();
      }
      this._isTransitioning = false;
      (0, import_jquery2.default)(this._element).trigger(shownEvent);
    };
    if (transition) {
      const transitionDuration = util_default.getTransitionDurationFromElement(this._dialog);
      (0, import_jquery2.default)(this._dialog).one(util_default.TRANSITION_END, transitionComplete).emulateTransitionEnd(transitionDuration);
    } else {
      transitionComplete();
    }
  }
  _enforceFocus() {
    (0, import_jquery2.default)(document).off(EVENT_FOCUSIN).on(EVENT_FOCUSIN, (event) => {
      if (document !== event.target && this._element !== event.target && (0, import_jquery2.default)(this._element).has(event.target).length === 0) {
        this._element.focus();
      }
    });
  }
  _setEscapeEvent() {
    if (this._isShown) {
      (0, import_jquery2.default)(this._element).on(EVENT_KEYDOWN_DISMISS, (event) => {
        if (this._config.keyboard && event.which === ESCAPE_KEYCODE) {
          event.preventDefault();
          this.hide();
        } else if (!this._config.keyboard && event.which === ESCAPE_KEYCODE) {
          this._triggerBackdropTransition();
        }
      });
    } else if (!this._isShown) {
      (0, import_jquery2.default)(this._element).off(EVENT_KEYDOWN_DISMISS);
    }
  }
  _setResizeEvent() {
    if (this._isShown) {
      (0, import_jquery2.default)(window).on(EVENT_RESIZE, (event) => this.handleUpdate(event));
    } else {
      (0, import_jquery2.default)(window).off(EVENT_RESIZE);
    }
  }
  _hideModal() {
    this._element.style.display = "none";
    this._element.setAttribute("aria-hidden", true);
    this._element.removeAttribute("aria-modal");
    this._element.removeAttribute("role");
    this._isTransitioning = false;
    this._showBackdrop(() => {
      (0, import_jquery2.default)(document.body).removeClass(CLASS_NAME_OPEN);
      this._resetAdjustments();
      this._resetScrollbar();
      (0, import_jquery2.default)(this._element).trigger(EVENT_HIDDEN);
    });
  }
  _removeBackdrop() {
    if (this._backdrop) {
      (0, import_jquery2.default)(this._backdrop).remove();
      this._backdrop = null;
    }
  }
  _showBackdrop(callback) {
    const animate = (0, import_jquery2.default)(this._element).hasClass(CLASS_NAME_FADE) ? CLASS_NAME_FADE : "";
    if (this._isShown && this._config.backdrop) {
      this._backdrop = document.createElement("div");
      this._backdrop.className = CLASS_NAME_BACKDROP;
      if (animate) {
        this._backdrop.classList.add(animate);
      }
      (0, import_jquery2.default)(this._backdrop).appendTo(document.body);
      (0, import_jquery2.default)(this._element).on(EVENT_CLICK_DISMISS, (event) => {
        if (this._ignoreBackdropClick) {
          this._ignoreBackdropClick = false;
          return;
        }
        if (event.target !== event.currentTarget) {
          return;
        }
        if (this._config.backdrop === "static") {
          this._triggerBackdropTransition();
        } else {
          this.hide();
        }
      });
      if (animate) {
        util_default.reflow(this._backdrop);
      }
      (0, import_jquery2.default)(this._backdrop).addClass(CLASS_NAME_SHOW);
      if (!callback) {
        return;
      }
      if (!animate) {
        callback();
        return;
      }
      const backdropTransitionDuration = util_default.getTransitionDurationFromElement(this._backdrop);
      (0, import_jquery2.default)(this._backdrop).one(util_default.TRANSITION_END, callback).emulateTransitionEnd(backdropTransitionDuration);
    } else if (!this._isShown && this._backdrop) {
      (0, import_jquery2.default)(this._backdrop).removeClass(CLASS_NAME_SHOW);
      const callbackRemove = () => {
        this._removeBackdrop();
        if (callback) {
          callback();
        }
      };
      if ((0, import_jquery2.default)(this._element).hasClass(CLASS_NAME_FADE)) {
        const backdropTransitionDuration = util_default.getTransitionDurationFromElement(this._backdrop);
        (0, import_jquery2.default)(this._backdrop).one(util_default.TRANSITION_END, callbackRemove).emulateTransitionEnd(backdropTransitionDuration);
      } else {
        callbackRemove();
      }
    } else if (callback) {
      callback();
    }
  }
  _adjustDialog() {
    const isModalOverflowing = this._element.scrollHeight > document.documentElement.clientHeight;
    if (!this._isBodyOverflowing && isModalOverflowing) {
      this._element.style.paddingLeft = `${this._scrollbarWidth}px`;
    }
    if (this._isBodyOverflowing && !isModalOverflowing) {
      this._element.style.paddingRight = `${this._scrollbarWidth}px`;
    }
  }
  _resetAdjustments() {
    this._element.style.paddingLeft = "";
    this._element.style.paddingRight = "";
  }
  _checkScrollbar() {
    const rect = document.body.getBoundingClientRect();
    this._isBodyOverflowing = Math.round(rect.left + rect.right) < window.innerWidth;
    this._scrollbarWidth = this._getScrollbarWidth();
  }
  _setScrollbar() {
    if (this._isBodyOverflowing) {
      const fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
      const stickyContent = [].slice.call(document.querySelectorAll(SELECTOR_STICKY_CONTENT));
      (0, import_jquery2.default)(fixedContent).each((index, element) => {
        const actualPadding2 = element.style.paddingRight;
        const calculatedPadding2 = (0, import_jquery2.default)(element).css("padding-right");
        (0, import_jquery2.default)(element).data("padding-right", actualPadding2).css("padding-right", `${parseFloat(calculatedPadding2) + this._scrollbarWidth}px`);
      });
      (0, import_jquery2.default)(stickyContent).each((index, element) => {
        const actualMargin = element.style.marginRight;
        const calculatedMargin = (0, import_jquery2.default)(element).css("margin-right");
        (0, import_jquery2.default)(element).data("margin-right", actualMargin).css("margin-right", `${parseFloat(calculatedMargin) - this._scrollbarWidth}px`);
      });
      const actualPadding = document.body.style.paddingRight;
      const calculatedPadding = (0, import_jquery2.default)(document.body).css("padding-right");
      (0, import_jquery2.default)(document.body).data("padding-right", actualPadding).css("padding-right", `${parseFloat(calculatedPadding) + this._scrollbarWidth}px`);
    }
    (0, import_jquery2.default)(document.body).addClass(CLASS_NAME_OPEN);
  }
  _resetScrollbar() {
    const fixedContent = [].slice.call(document.querySelectorAll(SELECTOR_FIXED_CONTENT));
    (0, import_jquery2.default)(fixedContent).each((index, element) => {
      const padding2 = (0, import_jquery2.default)(element).data("padding-right");
      (0, import_jquery2.default)(element).removeData("padding-right");
      element.style.paddingRight = padding2 ? padding2 : "";
    });
    const elements = [].slice.call(document.querySelectorAll(`${SELECTOR_STICKY_CONTENT}`));
    (0, import_jquery2.default)(elements).each((index, element) => {
      const margin = (0, import_jquery2.default)(element).data("margin-right");
      if (typeof margin !== "undefined") {
        (0, import_jquery2.default)(element).css("margin-right", margin).removeData("margin-right");
      }
    });
    const padding = (0, import_jquery2.default)(document.body).data("padding-right");
    (0, import_jquery2.default)(document.body).removeData("padding-right");
    document.body.style.paddingRight = padding ? padding : "";
  }
  _getScrollbarWidth() {
    const scrollDiv = document.createElement("div");
    scrollDiv.className = CLASS_NAME_SCROLLBAR_MEASURER;
    document.body.appendChild(scrollDiv);
    const scrollbarWidth = scrollDiv.getBoundingClientRect().width - scrollDiv.clientWidth;
    document.body.removeChild(scrollDiv);
    return scrollbarWidth;
  }
  static _jQueryInterface(config, relatedTarget) {
    return this.each(function() {
      let data = (0, import_jquery2.default)(this).data(DATA_KEY);
      const _config = {
        ...Default,
        ...(0, import_jquery2.default)(this).data(),
        ...typeof config === "object" && config ? config : {}
      };
      if (!data) {
        data = new Modal(this, _config);
        (0, import_jquery2.default)(this).data(DATA_KEY, data);
      }
      if (typeof config === "string") {
        if (typeof data[config] === "undefined") {
          throw new TypeError(`No method named "${config}"`);
        }
        data[config](relatedTarget);
      } else if (_config.show) {
        data.show(relatedTarget);
      }
    });
  }
};
(0, import_jquery2.default)(document).on(EVENT_CLICK_DATA_API, SELECTOR_DATA_TOGGLE, function(event) {
  let target;
  const selector = util_default.getSelectorFromElement(this);
  if (selector) {
    target = document.querySelector(selector);
  }
  const config = (0, import_jquery2.default)(target).data(DATA_KEY) ? "toggle" : {
    ...(0, import_jquery2.default)(target).data(),
    ...(0, import_jquery2.default)(this).data()
  };
  if (this.tagName === "A" || this.tagName === "AREA") {
    event.preventDefault();
  }
  const $target = (0, import_jquery2.default)(target).one(EVENT_SHOW, (showEvent) => {
    if (showEvent.isDefaultPrevented()) {
      return;
    }
    $target.one(EVENT_HIDDEN, () => {
      if ((0, import_jquery2.default)(this).is(":visible")) {
        this.focus();
      }
    });
  });
  Modal._jQueryInterface.call((0, import_jquery2.default)(target), config, this);
});
import_jquery2.default.fn[NAME] = Modal._jQueryInterface;
import_jquery2.default.fn[NAME].Constructor = Modal;
import_jquery2.default.fn[NAME].noConflict = () => {
  import_jquery2.default.fn[NAME] = JQUERY_NO_CONFLICT;
  return Modal._jQueryInterface;
};
var modal_default = Modal;

// dep:bootstrap_js_src_modal
var bootstrap_js_src_modal_default = modal_default;
export {
  bootstrap_js_src_modal_default as default
};
//# sourceMappingURL=bootstrap_js_src_modal.js.map
